## 2019-03-05

你的背包里应该经常放可以装温水的温水瓶，不喝或者少喝饮料和冷饮。因为冷的液体喝下去，需要你的肠胃等内脏温暖液体，这样就给身体带来更大的负荷，长期内脏出问题，容易引发一系列的疾病，甚至是癌症等等。

闹钟⏰一响，要不立刻起床，要不带着睡意继续睡下去，赖床既睡不好有浪费时间。早点起来，一天的时间就多了，可以做到的事情就多了；有睡意睡下去，睡眠质量就好，身体的休息效果就不会差。

坚持每天一个水果，例如每天坚持吃一个西红柿。水果里面有丰富的蔬菜和肉类都没有的微量元素。这是N多明星和美容师都知道的抗老美容的一个方法，女神们都知道。

吃东西时两边肌肉都要用到，要不然会变大小脸的哟~，吃饭时尽量要20分钟，尽量多咬，让食物更更烂点，食物停留在口的时间越长，分泌的消化液越多，食物更容易消化和吸收。



## 研究一下web缓存

1. 浏览器进行资源请求时，会判断`response headers`是否命中强缓存，如果命中，直接从本地取缓存，不会发送服务器请求。
2. 如果没有命中缓存，会发送到服务器，判断协商缓存是否命中，如果命中，服务器将请求返回，不会返回资源，让浏览器从本地读取缓存。如果不命中，服务器直接返回资源。

### from memory cache 和from disk cache

from memory cache: 从内存中取，直接从内存中取，不会走请求服务器这一步，当用户关闭这个页面时，这个资源就会被释放掉。

from disk cache： 和上面类似，资源都是从磁盘中取出，直接的取，不会请求服务器而且该资源不会随页面的关闭而被释放掉。

### 强缓存分为Expires和Cache-Control 

`Expires`，是一个时间点的字符串，第一次请求时，服务器会在返回头部加上`Expires`，下次请求时，在这个时间之前就会命中。这个代码时后台大哥写的。

```javascript


app.get('/', (req, res) => {
    const cssContent = path.join(__dirname, './html/index.html');
    fs.readFile(cssContent, function(err, data) {
          res.setHeader("Expires", new Date(Date.now() + 2592000000).toUTCString());
        res.end(data);
    })
});

```

`Cache-Control`，该值是利用`max-age`判断缓存的周期，时间是以秒为单位的，则命中缓存。

```javascript

app.get('/', (req, res) => {
    const cssContent = path.join(__dirname, './html/index.html');
    fs.readFile(cssContent, function(err, data) {
        res.setHeader("Cache-Control", "max-age=0");
        res.end(data);
    })
});

``` 

### 协商缓存 

协商缓存利用Last-Modified，if-Modified-Since和ETag，if-None-Match来实现。

`Last-Modified`：表示为实体头部部分，response返回，表示为字眼的最后更新时间。

`if-Modified-Since`: 通过比较两次的时间判断，资源在请求期间是否有修改，没有修改的话命中协商缓存，浏览器从缓存中读取资源；如果没有命中，资源有修改，则返回新的`Last-Modified`时间和请求的资源。

实现代码如下：

```javascript

    app.get('/', (req, res) => {
    const cssContent = path.join(__dirname, './html/index.html')
    fs.stat(cssContent, (err, start) => {
        if (req.headers['if-modified-since'] === start.mtime.toUTCString()) {
            res.writeHead(304, 'Not Modified');
            res.end();
        } else {
            fs.readFile(cssContent, function (err, data) {
                let lastModified = start.mtime.toUTCString();
                res.setHeader('Last-Modified', lastModified);
                res.writeHead(200, 'OK');
                res.end(data);
            })
        }
    })

});
```

### ETag，if-None-Match 

总觉得这个是补充上面`last-Modified`的不足的。因为总靠时间来判断改动是不够的。
比如，资源内容没有改动，但真的重复写入了；改动的地方是注释，不重要；`Last-Modified`无法精确到毫秒。

ETag: 为头部字段，表示自己的唯一标识，随服务器response返回；
if-None-Match: 通过比较头部的if-None-Match和当前资源中的etag是否一致，来判断资源是否修改过，如果没有修改，则命中缓存，从缓存中读取资源；如果修改过，服务器返回新的etag，和资源。

```javascript

app.get('/home', (req, res) => {
    const cssContent = path.join(__dirname, './html/index.html')
    fs.stat(cssContent, (err, start) => {
        let etag = md5(cssContent);
        if (req.headers['if-none-match'] === etag) {
            res.writeHead(304, 'Not Modified');
            res.end();
        } else {
            fs.readFile(cssContent, function (err, data) {
                res.setHeader('Etag', etag);
                res.writeHead(200, 'OK');
                res.end(data);
            })
        }
    })
});

```

### 总结

缓存的实现是这样子的，浏览器先看强缓存，如果命中强缓存了，就直接读取浏览器中的缓存，不会发送请求；没有命中强缓存，发送请求看协商缓存那边，如果协商缓存命中了，则返回304告诉浏览器你从浏览器中读取资源；如果没有命中就返回新的etag或者last-modified和资源

强缓存分为时间点Expires（在时间点前命中）和时间周期Cache-control（在周期内命中）

协商缓存分为last-modified和etag ;last-modified是看最后修改时间，仅靠时间判断是否修改；但这样子时间判断是有不足的，比如没有修改但是真的写入了，所以有了更好替换last-modified的etag，这个才是最好的协商判断方式：通过请求头部的if-none-match和etage比较，判断资源是否真的修改过。

这些代码都是后台小子写的，不和我前端有关。嘿嘿嘿。
